/* Group 03: julius-stabs-back */
/* Gautam Ahuja, Nistha Singh */ 
/* Terminal Symbols:  %token */ 
/* Non-Terminal Symbols:  %type */
/* Start Symbol: %start */

/* Declarations */
%{
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h> 
    #include "3_A5_translator.h"
    extern int yylex();     // Lexical Analyzer generated by Flex
    void yyerror(char *s);  // Error function for Bison
    extern char* yytext;    // yytext declaration
    extern int yylineno;    // yylineno declaration
    extern var_type_stack var_type;                 // push on type_specifier, pop on IDENTIFIER
    extern string_list* string_head;
    char* function_name;
    int next_instr_addr = 0;
%}

%union {
    char* intval;
    char* strval;
    char* charval;
    char* u_op;
    int count;
    int instr_no;
    char UNIARY_OPERATOR;
    struct symboltableentry* sym_entry;
    struct symboltype* sym_type;
    struct expression* expr;
    struct statement* stmt;
};

/* start symbol */
%start translation_unit

/* Terminals */
%token CHARACTER                        // "char"
%token ELSE                             // "else"  
%token FOR                              // "for"    
%token IF                               // "if"
%token INTEGER                          // "int"
%token RETURN                           // "return"
%token VOID                             // "void"
%token L_BOX_BRACKET                    // "["
%token R_BOX_BRACKET                    // "]"
%token L_PARENTHESIS                    // "("
%token R_PARENTHESIS                    // ")"
%token L_CURLY_BRACE                    // "{"
%token R_CURLY_BRACE                    // "}"
%token ARROW                            // "->"
%token AMPERSAND                        // "&"
%token ASTERISK                         // "*"
%token PLUS                             // "+"  
%token MINUS                            // "-"
%token EXCLAMATION                      // "!"
%token DIV                              // "/"
%token MOD                              // "%"
%token LESS_THAN                        // "<"
%token GREATER_THAN                     // ">" 
%token LESS_THAN_EQUAL                  // "<="
%token GREATER_THAN_EQUAL               // ">="
%token IS_EQUAL                         // "=="
%token NOT_EQUAL                        // "!="
%token LOGICAL_AND                      // "&&"
%token LOGICAL_OR                       // "||"
%token QUESTION                         // "?"
%token COLON                            // ":"
%token ASSIGN                           // "="
%token SEMICOLON                        // ";"
%token COMMA                            // ","
%token PUNCTUATOR
%token WS

%token <sym_entry> IDENTIFIER                       
%token <intval> INTEGER_CONSTANT
%token <charval> CHARACTER_CONSTANT
%token <strval> STRING_LITERAL

/* Operators Associativity and Precedence */
/* As per the slides of module 5 */
%right ASSIGN
%right QUESTION COLON
%left LOGICAL_OR
%left LOGICAL_AND
%left NOT_EQUAL IS_EQUAL
%left LESS_THAN LESS_THAN_EQUAL GREATER_THAN GREATER_THAN_EQUAL
%left PLUS MINUS
%left ASTERISK DIV MOD

/* Non-Terminals */
//Expressions
%type <expr> primary_expression expression postfix_expression unary_expression multiplicative_expression 
%type <expr> additive_expression relational_expression constant equality_expression logical_and_expression 
%type <expr> logical_or_expression conditional_expression assignment_expression expression_statement expression_opt
%type <stmt> statement compound_statement selection_statement iteration_statement jump_statement 
%type <stmt> block_item block_item_list block_item_list_opt M
%type <sym_entry> initializer direct_declarator init_declarator declarator identifier_opt func_ID
%type <u_op> pointer_opt pointer unary_operator
%type <count> argument_expression_list_opt argument_expression_list
%type <instr_no> N

%%
/* Grammar Rules */

/* EXPRESSIONS */
primary_expression : IDENTIFIER {
                            // new expression
                            $$ = create_expression();
                            $$->loc = $1;
                            // printf("primary-expression\n");
                        }
                   | constant {
                            // printf("primary-expression\n");
                            $$ = $1;
                        }
                   | STRING_LITERAL {
                            $$ = create_expression();
                            // generate a temporary entry for the string literal
                            $$->loc = gentemp(create_symboltype(TYPE_PTR, 1, NULL), $1);
                            $$->loc->type->ptr = create_symboltype(TYPE_CHAR, 1, NULL);
                            // Store the String in linekd list of strings
                            ll_insert(string_head, $1);
                            // calculate length of string_head
                            int length = ll_length(string_head);
                            length = length - 1;
                            // printf("\n\nLENGTH %d\n\n", length);
                            // convert to string
                            char* tempLength = (char*)malloc(sizeof(char)*10);
                            sprintf(tempLength, "%d", length);
                            // emit the results, set size of linked list
                            emit(OP_ASSIGN_STR, tempLength, NULL, $$->loc->name);
                            // printf("primary-expression\n");
                        }
                   | L_PARENTHESIS expression R_PARENTHESIS {
                            $$ = $2;
                            // printf("primary-expression\n");
                        }
                   ;

constant : INTEGER_CONSTANT {
                $$ = create_expression();
                // generate a temporary entry for the integer constant
                $$->loc = gentemp(create_symboltype(TYPE_INT, 1, NULL), $1);
                // emit the results
                emit(OP_ASSIGN, $1, NULL, $$->loc->name);

            }
         | CHARACTER_CONSTANT{
                $$ = create_expression();
                // generate a temporary entry for the character constant
                $$->loc = gentemp(create_symboltype(TYPE_CHAR, 1, NULL), $1);
                // emit the results
                emit(OP_ASSIGN, $1, NULL, $$->loc->name);
            }
         ;

postfix_expression : primary_expression {
                            $$ = $1;
                            $$->arrBase = $1->loc;  // set the array base to the location of the primary expression
                            // printf("postfix-expression\n");
                        }
                   | postfix_expression L_BOX_BRACKET expression R_BOX_BRACKET {
                            $$ = create_expression();
                            // set flag to array
                            $$->isArray = true;
                            $$->loc = $3->loc;
                            // set the array base to the location of the postfix expression
                            $$->arrBase = $1->loc;
                            // printf("postfix-expression\n");
                        }
                   | postfix_expression L_PARENTHESIS argument_expression_list_opt R_PARENTHESIS {
                            // This is a function call
                            $$ = create_expression();
                            // check if the postfix expression points to a function symbol table entry
                            if($1->loc->next != NULL){
                                // generate temp of type of return value of function.
                                // f# = call function, para#
                                if($1->loc->next->_retVal->type != TYPE_VOID){
                                    $$->loc = gentemp($1->loc->next->_retVal, NULL);
                                    $$->arrBase = $$->loc;
                                    // emit the code for function call. Paramter count is in argument_expression_list_opt
                                    // convert $3 to string
                                    char intTOstr[10];
                                    sprintf(intTOstr, "%d", $3);
                                    emit(OP_CALL, $1->loc->name, intTOstr, $$->loc->name);
                                }
                                else{
                                    // void type call, no assign
                                    char intTOstr[10];
                                    sprintf(intTOstr, "%d", $3);
                                    emit(OP_CALL_VOID, $1->loc->name, intTOstr, NULL);
                                }
                            }
                            // function not defined
                            else{
                                char* temp = "Function not defined for ";
                                char* temp2 = (char*)malloc(strlen(temp) + strlen($1->loc->name) + 1);
                                sprintf(temp2, "%s%s", temp, $1->loc->name);
                                yyerror(temp2);
                            }
                            // printf("postfix-expression\n");
                        }
                   | postfix_expression ARROW IDENTIFIER {
                            // we do not have any structs or classes in our language.
                            $$ = $1;
                            // printf("postfix-expression\n");
                        }
                   ;

argument_expression_list_opt : argument_expression_list {
                                    // this is parameter list
                                    $$ = $1;                                    
                                }
                             | {
                                    $$ = 0;
                                }
                             ;

argument_expression_list : assignment_expression {
                                // this is single parameter
                                $$ = 1;
                                // emit the code for parameter
                                emit(OP_PARAM, NULL, NULL, $1->loc->name);
                                // printf("argument-expression-list\n");
                            }
                         | argument_expression_list COMMA assignment_expression {
                                // this is a list of parameters
                                $$ = $1 + 1;
                                // emit the code for parameter
                                emit(OP_PARAM, NULL, NULL, $3->loc->name);
                                // printf("argument-expression-list\n");
                            }
                         ;

unary_expression : postfix_expression {
                        $$ = $1;
                        // printf("unary-expression\n");
                    }
                 | unary_operator unary_expression {
                        // this is rule used for unary operators preceding a postfix expression
                        $$ = create_expression();
                        
                        // check the unary_operator type
                        if(strcmp($1, "&") == 0){
                            int temp = 0;
                            /*
                            if($2->isArray){
                                // first get arr[i] and then &arr[i]
                                // // printf("\n\n RUNNN \n\n");
                                $$->loc = gentemp(create_symboltype(TYPE_PTR, 1, $2->loc->type), NULL);
                                emit(OP_ASSIGN_BOX, $2->arrBase->name, $2->loc->name, $$->loc->name);
                                $$->isPtr = true;
                                temp++;
                            }
                            */
                            // an operator is refering to a variable address. It has to be a pointer
                            // struct symboltype* temp = create_symboltype(TYPE_PTR, 1, NULL);
                            $$->arrBase = gentemp(create_symboltype(TYPE_PTR, 1, NULL), NULL);
                            $$->arrBase->type->ptr = $2->arrBase->type;
                            // emit the code for refering
                            (temp > 0) ? emit(OP_ASSIGN_AMPER, $$->loc->name, NULL, $$->arrBase->name) : emit(OP_ASSIGN_AMPER, $2->arrBase->name, NULL, $$->arrBase->name);
                        }

                        else if(strcmp($1, "*") == 0){
                            // an operator is dereferencing a pointer. It has returned a value
                            $$->loc = gentemp($2->arrBase->type->ptr, NULL);
                            $$->isPtr = true;
                            $$->arrBase = $2->arrBase;
                            // emit the code for dereferencing
                            emit(OP_ASSIGN_ASTERISK, $2->arrBase->name, NULL, $$->loc->name);
                        }

                        else if(strcmp($1, "+") == 0){
                            // unary plus is normal plus, propagate the type
                            $$ = $2;
                        }

                        else if(strcmp($1, "-") == 0){
                            // unary minus is flipping the sign, propagate the results
                            struct symboltype* temp = create_symboltype($2->arrBase->type->type, 1, NULL);
                            $$->arrBase = gentemp(temp, NULL);
                            // emit the code for unary expression
                            emit(OP_UMINUS, $2->arrBase->name, NULL, $$->arrBase->name);

                        }
                        else if(strcmp($1, "!") == 0){
                            // unary not is flipping the boolean. Reverse the list of true and false
                            if($2->isBool){
                                // flip the lists
                                $$->trueList = $2->falseList;
                                $$->falseList = $2->trueList;
                                $$->isBool = true;
                                $$->arrBase = $2->arrBase;
                                $$->loc = $2->loc;
                            }
                            else{
                                // wrong type for unary not
                                char* temp = "Boolean Expressions not allowed";
                                yyerror(temp);
                            }
                        }
                        // printf("unary-expression\n");
                    }
                 ;

unary_operator : AMPERSAND {
                        $$ = "&";
                        // printf("unary-operator\n");
                    }
               | ASTERISK {
                        $$ = "*";
                        // printf("unary-operator\n");
                    }
               | PLUS {
                        $$ = "+";
                        // printf("unary-operator\n");
                    }
               | MINUS {
                        $$ = "-";
                        // printf("unary-operator\n");
                    }
               | EXCLAMATION {
                        $$ = "!";
                        // printf("unary-operator\n");
                    }
               ;

multiplicative_expression : unary_expression {
                                    $$ = create_expression();
                                    // check if the expression is a pointer
                                    if($1->isPtr){
                                        // copy the loation of expression to temp
                                        $$->loc = $1->loc;
                                    } else if($1->isArray){    // check if array
                                        // new temporary entry for array in current symbol table
                                        $$->loc = gentemp($1->loc->type, $1->loc->initial_value);
                                        // emit the code for array
                                        emit(OP_ASSIGN_BOX, $1->arrBase->name, $1->loc->name, $$->loc->name);
                                        // reset array flag
                                        $1->isArray = false;
                                    }else{
                                        $$ = $1;
                                        $$->loc = $1->arrBase;
                                    }
                                    // printf("multiplicative-expression\n");
                                }
                          | multiplicative_expression ASTERISK unary_expression {
                                    // check if both expressions are of same type or need conversion
                                    if(typecheck($1->loc->type, $3->arrBase->type)){
                                        $$ = create_expression();
                                        // t# = a*b; of type of a
                                        $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                        // emit the code for multiplication
                                        emit(OP_MULT, $1->loc->name, $3->arrBase->name, $$->loc->name);
                                    }
                                    else{
                                        // conversion ???
                                        yyerror("Type mismatch in multiplicative MULT expression");
                                    }
                                    // printf("multiplicative-expression\n");
                                }
                          | multiplicative_expression DIV unary_expression {
                                    if(typecheck($1->loc->type, $3->arrBase->type)){
                                        $$ = create_expression();
                                        // t# = a/b; of type of a
                                        $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                        // emit the code for division
                                        emit(OP_DIV, $1->loc->name, $3->arrBase->name, $$->loc->name);
                                    }
                                    else{
                                        // conversion ???
                                        yyerror("Type mismatch in multiplicative DIV expression");
                                    }
                                    // printf("multiplicative-expression\n");
                                }
                          | multiplicative_expression MOD unary_expression {
                                    if(typecheck($1->loc->type, $3->arrBase->type)){
                                        $$ = create_expression();
                                        // t# = a%b; of type of a
                                        $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                        // emit the code for modulus
                                        emit(OP_MOD, $1->loc->name, $3->arrBase->name, $$->loc->name);  
                                    }
                                    else{
                                        // conversion ???
                                        yyerror("Type mismatch in multiplicative MOD expression");
                                    }
                                    // printf("multiplicative-expression\n");
                                }
                          ;

additive_expression : multiplicative_expression {
                            $$ = $1;
                            // printf("additive-expression\n");
                        }
                    | additive_expression PLUS multiplicative_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $$ = create_expression();
                                // t# = a+b; of type of a
                                $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                // emit the code for addition
                                emit(OP_PLUS, $1->loc->name, $3->loc->name, $$->loc->name);
                            }
                            else{
                                // conversion ???
                                yyerror("Type mismatch in additive PLUS expression");
                            }
                            // printf("additive-expression\n");
                        }
                    | additive_expression MINUS multiplicative_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $$ = create_expression();
                                // t# = a-b; of type of a
                                $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                // emit the code for subtraction
                                emit(OP_MINUS, $1->loc->name, $3->loc->name, $$->loc->name);
                            }
                            else{
                                // conversion ???
                                yyerror("Type mismatch in additive MINUS expression");
                            }
                            // printf("additive-expression\n");
                        }
                    ; 

relational_expression : additive_expression {
                                $$ = $1;
                                // printf("relational-expression\n");
                            }
                      | relational_expression LESS_THAN additive_expression {
                            // type check 
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $$ = create_expression();
                                $$->loc = $1->loc;
                                $$->isBool = true;
                                // make true and false lists
                                $$->trueList = makelist(nextInstr());
                                $$->falseList = makelist(nextInstr() + 1);
                                // t# = a<b; of type of a
                                // emit the code for less than
                                emit(OP_LT, $1->loc->name, $3->loc->name, NULL);
                                emit(OP_GOTO, NULL, NULL, NULL);
                            }
                            else{
                                // conversion ???
                                yyerror("Type mismatch in relational LESS_THAN expression");
                            }
                            // printf("relational-expression\n");
                        }
                      | relational_expression GREATER_THAN additive_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $$ = create_expression();
                                $$->loc = $1->loc;
                                $$->isBool = true;
                                // make true and false lists
                                $$->trueList = makelist(nextInstr());
                                $$->falseList = makelist(nextInstr() + 1);
                                // t# = a>b; of type of a
                                // emit the code for greater than
                                emit(OP_GT, $1->loc->name, $3->loc->name, NULL);
                                emit(OP_GOTO, NULL, NULL, NULL);
                            }
                            else{
                                // conversion ???
                                yyerror("Type mismatch in relational GREATER_THAN expression");
                            }
                            // printf("relational-expression\n");
                        }
                      | relational_expression LESS_THAN_EQUAL additive_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $$ = create_expression();
                                $$->loc = $1->loc;
                                $$->isBool = true;
                                // make true and false lists
                                $$->trueList = makelist(nextInstr());
                                $$->falseList = makelist(nextInstr() + 1);
                                // t# = a<=b; of type of a
                                // emit the code for less than equal
                                emit(OP_LT_EQUALS, $1->loc->name, $3->loc->name, NULL);
                                emit(OP_GOTO, NULL, NULL, NULL);
                            }
                            else{
                                // conversion ???
                                yyerror("Type mismatch in relational LESS_THAN_EQUAL expression");
                            }
                            // printf("relational-expression\n");
                        }
                      | relational_expression GREATER_THAN_EQUAL additive_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $$ = create_expression();
                                $$->loc = $1->loc;
                                $$->isBool = true;
                                // make true and false lists
                                $$->trueList = makelist(nextInstr());
                                $$->falseList = makelist(nextInstr() + 1);
                                // t# = a>=b; of type of a
                                // emit the code for greater than equal
                                emit(OP_GT_EQUALS, $1->loc->name, $3->loc->name, NULL);
                                emit(OP_GOTO, NULL, NULL, NULL);
                            }
                            else{
                                // conversion ???
                                yyerror("Type mismatch in relational GREATER_THAN_EQUAL expression");
                            }
                            // printf("relational-expression\n");
                        }
                      ;

equality_expression : relational_expression {
                            $$ = $1;
                            // printf("equality-expression\n");
                        }
                    | equality_expression IS_EQUAL relational_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $1 = bool2int($1);
                                $3 = bool2int($3);
                                $$ = create_expression();
                                $$->isBool = true;
                                $$->loc = $1->loc;
                                $$->trueList = makelist(nextInstr());
                                $$->falseList = makelist(nextInstr() + 1);
                                // if a == b ..
                                emit(OP_EQUALS, $1->loc->name, $3->loc->name, NULL);
                                emit(OP_GOTO, NULL, NULL, NULL);
                            }
                            // printf("equality-expression\n");
                        }
                    | equality_expression NOT_EQUAL relational_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $1 = bool2int($1);
                                $3 = bool2int($3);
                                $$ = create_expression();
                                $$->isBool = true;
                                $$->loc = $1->loc;
                                $$->trueList = makelist(nextInstr());
                                $$->falseList = makelist(nextInstr() + 1);
                                // if a != b ..
                                emit(OP_NOT_EQUALS, $1->loc->name, $3->loc->name, NULL);
                                emit(OP_GOTO, NULL, NULL, NULL);
                            }
                            // printf("equality-expression\n");
                        }
                    ;

logical_and_expression : equality_expression {
                                $$ = $1;
                                // printf("logical-AND-expression\n");
                            }
                       | logical_and_expression LOGICAL_AND N equality_expression {
                                $4 = int2bool($4);
                                $1 = int2bool($1);
                                $$ = create_expression();
                                $$->loc = $1->loc;
                                $$->isBool = true;
                                backpatch($1->trueList, $3);
                                $$->trueList = $4->trueList;
                                $$->falseList = merge($1->falseList, $4->falseList);
                                // printf("logical-AND-expression\n");
                            }
                       ;

logical_or_expression : logical_and_expression {
                                $$=$1;
                                // printf("logical-OR-expression\n");
                            }
                      | logical_or_expression LOGICAL_OR N logical_and_expression {
                                $4 = int2bool($4);
                                $1 = int2bool($1);
                                $$ = create_expression();
                                $$->loc = $1->loc;
                                $$->isBool = true;
                                backpatch($1->falseList, $3);
                                $$->trueList = merge($1->trueList, $4->trueList);
                                $$->falseList = $4->falseList;
                                // printf("logical-OR-expression\n");
                            }
                      ;

conditional_expression : logical_or_expression {
                                $$ = $1;
                                // printf("conditional-expression\n");
                            }
                       | logical_or_expression M QUESTION N expression M COLON N conditional_expression {
                                $$->loc = gentemp($5->loc->type, NULL);
                                update_type($$->loc, $5->loc->type);
                                // emit
                                emit(OP_ASSIGN, $9->loc->name, NULL, $$->loc->name);
                                int* tempList = makelist(nextInstr());
                                emit(OP_GOTO, NULL, NULL, NULL);                // Fall Check N
                                backpatch($6->nextList, nextInstr());
                                emit(OP_ASSIGN, $5->loc->name, NULL, $$->loc->name);
                                int* tempList2 = makelist(nextInstr());
                                tempList = merge(tempList, tempList2);
                                emit(OP_GOTO, NULL, NULL, NULL);                   // Fall Check M
                                backpatch($2->nextList, nextInstr());
                                $1 = int2bool($1);
                                backpatch($1->trueList, $4);
                                backpatch($1->falseList, $8);
                                backpatch(tempList, nextInstr());

                                // printf("conditional-expression\n");
                            }
                       ;

assignment_expression : conditional_expression {
                                $$ = $1;
                                // printf("assignment-expression\n");
                            }
                      | unary_expression ASSIGN assignment_expression {
                                // check array
                                if($1->isArray){
                                    emit(OP_BOX_ASSIGN, $1->loc->name, $3->loc->name, $1->arrBase->name);
                                }
                                else if($1->isPtr){
                                    emit(OP_ASTERISK_ASSIGN, $3->loc->name, NULL, $1->arrBase->name);
                                }
                                else{
                                    // chek both type
                                    if(!typecheck($1->loc->type, $3->loc->type)){
                                        yyerror("Type mismatch in assignment expression");
                                    }
                                    emit(OP_ASSIGN, $3->loc->name, NULL, $1->arrBase->name);
                                }
                                $$ = $3;
                                // printf("assignment-expression\n");
                            }
                      ;

expression : assignment_expression {
                    $$ = $1;
                    // printf("expression\n");
                }
           ;

/* DECLARATIONS */

declaration : type_specifier init_declarator SEMICOLON {
                    // Reducing function_definition to declaration, move the new symbol table pointer NULL.
		            new_ST = NULL;
                    // printf("declaration\n");
                }
            ;

init_declarator : declarator {
                        // check if the current table is global or not
                        if (currST == globalST){
                            if($1->type->type == TYPE_INT || $1->type->type == TYPE_CHAR || $1->type->type == TYPE_PTR || $1->type->type == TYPE_ARRAY){
                                // assign initial value to the symbol table entry
                                $1->initial_value = "0";
                            }
                        }
                        // printf("init-declarator\n");
                    }
                | declarator ASSIGN initializer {
                        // check if a value exist in initializer
                        if($3 != NULL){
                                // assign value to the symbol table entry
                                $1->initial_value = $3->initial_value;
                                // update type of initializer
                                update_type($3, $1->type);
                            }
                        emit(OP_ASSIGN, $3->name, NULL, $1->name);
                        // printf("init-declarator\n"); 
                    }
                ;

type_specifier : VOID {
                        // printf("type-specifier\n");
                        push(&var_type, TYPE_VOID);
                    }
               | CHARACTER {
                        // printf("type-specifier\n");
                        push(&var_type, TYPE_CHAR);
                    }
               | INTEGER {
                        // printf("type-specifier\n");
                        push(&var_type, TYPE_INT);
                    }
               ;

declarator : pointer_opt direct_declarator {
                    if($1 != NULL){
                        struct symboltype* temp = create_symboltype(TYPE_PTR, 1, NULL);
                        if($2->next == NULL){
                            // it is an Array
                            temp->ptr = $2->type;
                            /*
                            if ($2->type->type == TYPE_ARRAY){
                                // printf("\n TYPE %d and %d and %d\n", temp->type, temp->ptr->type, temp->ptr->ptr->type);
                            }
                            */
                            update_type($2, temp);
                        }
                        else{
                            // it is a function
                            temp->ptr = $2->next->_retVal;
                            $2->next->_retVal = temp;
                        }
                    }
                    $$ = $2;
                    // printf("declarator\n");
                }
           ;

pointer_opt : pointer {$$ = $1;}
            | {$$ = NULL;}
            ;

direct_declarator : IDENTIFIER {
                            // new symbol table entry
                            $1 = lookup(currST, $1->name);
                            // typeentry
                            update_type($1, create_symboltype(pop(&var_type), 1, NULL));
                            $$ = $1;
                            // printf("direct-declarator\n");
                        }
                  | IDENTIFIER L_BOX_BRACKET INTEGER_CONSTANT R_BOX_BRACKET {
                            $1 = lookup(currST, $1->name);
                            // type entry
                            update_type($1, create_symboltype(pop(&var_type), 1, NULL));
                            // set array flag
                            update_type($1, create_symboltype(TYPE_ARRAY, atoi($3), $1->type));
                            // // printf("\nNAME %s and WIDTH %d\n", $1->name, $1->type->width);
                            $$ = $1;
                            // printf("direct-declarator\n");
                        }
                  | func_ID L_PARENTHESIS new_table parameter_list_opt R_PARENTHESIS {
                            // this is where the function is defined and new symbol table is created for 
                            // IDENTIFIER has parsed as a symbol table entry to the global symbol table

                            // return type is that of func_ID
                            enum symboltype_enum tempReturn = $1->type->type;

                            // update_type($1, create_symboltype($1->type->type, 1, NULL));

                            $1->category = TYPE_FUNCTION;
                            // all functions are of size size_of_pointer
                            $1->size = size_of_pointer;
                            // create a new symbol table for the function
                            // currST->name = $1->name;
                            // link the symbol table to the global symbol table
                            $1->next = currST;
                            // store return value
                            if(tempReturn == TYPE_VOID){
                                currST->_retVal = create_symboltype(TYPE_VOID, 1, NULL);
                            }
                            else{
                                symboltableentry* storeReturn = lookup(currST, "retValue");
                                update_type(storeReturn, create_symboltype(tempReturn, 1, NULL));
                                currST->_retVal = storeReturn->type;
                                storeReturn->category = TYPE_RETURN;
                            }
                            // keep an instance
                            // Reducing function name and parameter list to direct_declarator.
                            // This will be reduced to type_specifier declarator {block_item_list_opt}.
                            // need an instance of current symbol table for block_item_list_opt
                            new_ST = currST;
                            // // printf("\n\nName %s\n\n",new_ST->name);
                            currST = globalST;
                            // // printf("\n\nName %s\n\n",currST->name);
                            $$ = $1;
                            // printf("direct-declarator\n");
                        }
                  ;

parameter_list_opt : parameter_list
                   | 
                   ;

pointer : ASTERISK {
                $$ = "*";
                // printf("pointer\n");
            }
        ;

parameter_list : parameter_declaration 
                    {
                        // printf("parameter-list\n");
                    }
               | parameter_list COMMA parameter_declaration 
                    {
                        // printf("parameter-list\n");
                    }
               ;

parameter_declaration : type_specifier pointer_opt identifier_opt {
                                if($2 != NULL && $3 != NULL){
                                    $3 = lookup(currST, $3->name);
                                    struct symboltype* tempType = create_symboltype(TYPE_PTR, 1, NULL);
                                    tempType->ptr = create_symboltype(pop(&var_type), 1, NULL);
                                    update_type($3, tempType);
                                    $3->category = TYPE_PARAM;
                                    // _argList PushBack ????
                                    push_args(currST, $3);
                                }
                                else if($2 == NULL && $3 != NULL){
                                    $3 = lookup(currST, $3->name);
                                    update_type($3, create_symboltype(pop(&var_type), 1, NULL));
                                    $3->category = TYPE_PARAM;
                                    // _argList PushBack ????
                                    push_args(currST, $3);
                                }
                                else{
                                        // do nothing
                                }
                                /*
                                else if ($2 != NULL && $3 == NULL){
                                    struct symboltype* tempType = create_symboltype(TYPE_PTR, 1, NULL);
                                    tempType->ptr = create_symboltype(pop(&var_type), 1, NULL);
                                    struct symboltableentry* tempPara = genparam(tempType, NULL);
                                    update_type(tempPara, tempType);
                                    // _argList PushBack ????
                                    push_args(currST, tempPara);
                                }
                                else{
                                    struct symboltableentry* tempPara = genparam(create_symboltype(pop(&var_type), 1, NULL), NULL);
                                    // _argList PushBack ????
                                    push_args(currST, tempPara);
                                }
                                */
                                // printf("parameter-declaration\n");
                            }
                      ;

identifier_opt : IDENTIFIER {$$ = $1;}
               | {$$ = NULL;}
               ;

initializer : assignment_expression {
                    $$ = $1->loc;
                    // printf("initializer\n");
                }
            ;

/* STATEMENTS */
statement : compound_statement {
                    // This is the Block. It contains a list of statements
                    $$ = $1;
                    // printf("statement\n");
                }
          | expression_statement {
                    // Expressions -- Assignment, Function Call, Operations, etc.
                    $$ = create_statement();
                    $$->nextList = $1->nextList;
                    // printf("statement\n");
                }
          | selection_statement {
                    // If-Else, conditional
                    $$ = $1;
                    // printf("statement\n");
                }
          | iteration_statement {
                    // For Koop
                    $$ = $1;
                    // printf("statement\n");
                }
          | jump_statement {
                    // This is a return statement
                    $$ = $1;
                    update_return_ST(currST, 1);
                    // printf("statement\n");
                }
          ;

compound_statement : L_CURLY_BRACE block_item_list_opt R_CURLY_BRACE {
                            $$ = $2;
                            // printf("compound-statement\n");
                        }
                   ;

block_item_list_opt : block_item_list {
                            $$ = $1;
                        }
                    | {
                            $$ = create_statement();
                        }
                    ;

block_item_list : block_item {
                        $$ = $1;
                        // printf("block-item-list\n");
                    }
                | block_item_list N block_item {
                        $$ = $3;
                        backpatch($1->nextList, $2);                        
                        // printf("block-item-list\n");
                    }
                ;   

block_item : declaration {
                    $$ = create_statement();
                    // printf("block-item\n");
                }
           | statement {
                    $$ = $1;
                    // printf("block-item\n");
                }
           ;

expression_statement : expression_opt SEMICOLON {
                            $$ = $1;
                            // printf("expression-statement\n");
                        }
                     ;

expression_opt : expression {
                    $$ = $1;
                    $$->returnLabel = 0;
                }
               | {
                    $$ = create_expression();
                    $$->returnLabel = 1;
                 }
               ;

selection_statement : IF L_PARENTHESIS expression M R_PARENTHESIS N statement M {
                            backpatch($4->nextList, nextInstr());
                            $3 = int2bool($3);
                            $$ = create_statement();
                            backpatch($3->trueList, $6);    //if TRUE, go to next_instr_addr i.e just before statement body
                            int* tempList = merge($3->falseList, $7->nextList); //merge falselist of expression, nextlist of statement and second augmented_goto
                            $$->nextList = merge($8->nextList, tempList); //merge nextlist of statement and augmented_goto
                            // printf("selection-statement\n");
                        }
                    | IF L_PARENTHESIS expression M R_PARENTHESIS N statement M ELSE N statement {
                                // // printf("\n\nRUNNN forrest RUNNN\n\n");
                                backpatch($4->nextList, nextInstr());
                                $3 = int2bool($3);
                                $$ = create_statement();
                                backpatch($3->trueList, $6);    //if TRUE, go to next_instr_addr i.e just before statement body
                                backpatch($3->falseList, $10);  //if FALSE, go to next_instr_addr i.e just before else body
                                int* tempList = merge($7->nextList, $8->nextList); //merge falselist of expression, nextlist of statement and second augmented_goto
                                $$->nextList = merge($11->nextList, tempList); //merge nextlist of statement and augmented_goto
                                // printf("selection-statement\n");
                            }
                    ;

iteration_statement : FOR L_PARENTHESIS expression_opt SEMICOLON N expression_opt SEMICOLON N expression_opt M R_PARENTHESIS N statement {
                            $$ = create_statement();
                            if($6->returnLabel==1){
                                // infinite loop action
                                backpatch($10->nextList, $12);
                                backpatch($13->nextList, $8);
                                char intTOstr[10];
                                sprintf(intTOstr, "%d", $5);
                                emit(OP_GOTO, NULL, NULL, intTOstr);
                            }
                            else{
                                $6 = int2bool($6);       // check to bool
                                backpatch($6->trueList, $12);
                                backpatch($10->nextList, $5);
                                backpatch($13->nextList, $8);
                                char intTOstr[10];
                                sprintf(intTOstr, "%d", $8);
                                emit(OP_GOTO, NULL, NULL, intTOstr);
                                $$->nextList = $6->falseList;   // exit when false
                            }
                            // printf("iteration-statement\n");
                        }
                    ;

jump_statement : RETURN expression_opt SEMICOLON {
                        if($2->returnLabel == 1){
                            // return statement without any expression
                            // function return type is void -- check
                            if(!typecheck(currST->_retVal, create_symboltype(TYPE_VOID, 1, NULL))){
                                // return type mismatch
                                yyerror("Return type mismatch with Function type");
                            }
                            $$ = create_statement();
                            // emit the code for return
                            emit(OP_RETURN_VOID, NULL, NULL, NULL);
                        }
                        /*
                        else if($2->arrBase->type->type == TYPE_FUNC){
                            // typecheck the return type of function
                            if(!typecheck(currST->_retVal, $2->loc->next->_retVal)){
                                // return type mismatch
                                yyerror("Return type mismatch with Function type");
                            }
                            $$ = create_statement();
                            // emit the code for return
                            emit(OP_RETURN, NULL, NULL, $2->loc->name);
                        }
                        */
                        else{
                            // return statement with expression
                            // check that the expression type is same as function return type
                            if(!typecheck(currST->_retVal, $2->loc->type)){
                                // return type mismatch
                                yyerror("Return type mismatch with Function type");
                            }
                            $$ = create_statement();
                            // emit the code for return
                            emit(OP_RETURN, NULL, NULL, $2->loc->name);
                        }
                        // printf("jump-statement\n");
                    }
               ;

/* TRANSLATION UNIT */
translation_unit : external_declaration 
                    {
                        // printf("translation-unit\n");
                    }
                 | translation_unit external_declaration 
                    {
                        // printf("translation-unit\n");
                    }
                 ;

external_declaration : declaration 
                        {
                            // printf("external-declaration\n");
                        }
                     | function_definition 
                        {
                            // printf("external-declaration\n");
                        }
                     ;

function_definition : type_specifier declarator switch_table compound_statement {
                            // we have reduced function. Lose the instance of current symbol table
                            // check if there is a return statement present
                            if(currST->returnLabel == 0){
                                // return statement not present
                                // it is of type void
                                emit(OP_RETURN_VOID, NULL, NULL, NULL);
                                // backpatch the return label
                                backpatch($4->nextList, nextInstr()-1);
                            }
                            else{
                                // just backpatch the end of function for any dangling statements
                                backpatch($4->nextList, nextInstr());
                            }
                            new_ST = NULL;
                            // emit the code for function definition
                            emit(OP_ENDFUNC, NULL, NULL, currST->name);
                            // just to be safe, set the current symbol table to global symbol table
                            currST = globalST;
                            // printf("function-definition\n");
                        }
                    ;

/* AUX RULES */

M : {
        $$ = create_statement();
        $$->nextList = makelist(nextInstr());
        emit(OP_GOTO, NULL, NULL, NULL);
        // printf("M\n");
    }
  ;

func_ID : IDENTIFIER {
                function_name = $1->name;
                $$ = $1;
                // store for function return type
                update_type($$, create_symboltype(pop(&var_type), 1, NULL));
                // // printf("\n\nTYPE %d\n\n", $$->type->type);
                // // printf("func-ID\n");
            }
        ;

new_table : {   
                char* entry = function_name;
                // // printf("\n\n\t\t ST \t\t %s\n\n", entry);
                currST = create_symboltable(entry, globalST);
                // update_type(lastEntry, create_symboltype(TYPE_FUNC, 1, NULL));
                // lastEntry->category = TYPE_FUNC;
                // lastEntry->next = currST;
                // printf("new-table\n");
            }
          ;

N : {
        // next instruction
        $$ = nextInstr();
        // // printf("\n\nNUMER %d\n\n", $$);
        // printf("next-instruction\n");
    }
  ;

switch_table : {
                    currST = new_ST;
                    emit(OP_FUNC, NULL, NULL, currST->name);
                    //// printf("\n\nswitch-table\n\n");
               }
             ;

%%
/* C Code for functions */

void yyerror(char *s) {
    printf("Error: %s on '%s' at line %d\n", s, yytext, yylineno);
    exit(1);
}