/* Group 03: julius-stabs-back */
/* Gautam Ahuja, Nistha Singh */ 
/* Terminal Symbols:  %token */ 
/* Non-Terminal Symbols:  %type */
/* Start Symbol: %start */

/* Declarations */
%{
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    extern int yylex();     // Lexical Analyzer generated by Flex
    void yyerror(char *s);  // Error function for Bison
%}

%union {
    int ival;
    char* str;
};

/* Terminals */
%token CHARACTER                        // "char"
%token ELSE                             // "else"  
%token FOR                              // "for"    
%token IF                               // "if"
%token INTEGER                          // "int"
%token RETURN                           // "return"
%token VOID                             // "void"
%token L_BOX_BRACKET                    // "["
%token R_BOX_BRACKET                    // "]"
%token L_PAREN                          // "("
%token R_PAREN                          // ")"
%token L_CURLY_BRACE                    // "{"
%token R_CURLY_BRACE                    // "}"
%token ARROW                            // "->"
%token AMPERSAND                        // "&"
%token ASTERISK                         // "*"
%token PLUS                             // "+"  
%token MINUS                            // "-"
%token EXCLAMATION                      // "!"
%token DIV                              // "/"
%token MOD                              // "%"
%token LESS_THAN                        // "<"
%token GREATER_THAN                     // ">" 
%token LESS_THAN_EQUAL                  // "<="
%token GREATER_THAN_EQUAL               // ">="
%token DOUBLE_EQUAL                     // "=="
%token NOT_EQUAL                        // "!="
%token LOGICAL_AND                      // "&&"
%token LOGICAL_OR                       // "||"
%token QUESTION                         // "?"
%token COLON                            // ":"
%token ASSIGN                           // "="
%token SEMICOLON                        // ";"
%token COMMA                            // ","
%token PUNCTUATOR
%token WS

%token IDENTIFIER                       
%token <ival> INTEGER_CONSTANT
%token <str> CHARACTER_CONSTANT
%token <str> STRING_LITERAL

/* start symbol */
%start translation_unit

/* Operators Associativity and Precedence */
/* As per the slides of module 5 */
%right ASSIGN
%right QUESTION COLON
%left LOGICAL_OR
%left LOGICAL_AND
%left NOT_EQUAL DOUBLE_EQUAL
%left LESS_THAN LESS_THAN_EQUAL GREATER_THAN GREATER_THAN_EQUAL
%left PLUS MINUS
%left ASTERISK DIV MOD

%%
/* Grammar Rules */

/* EXPRESSIONS */
primary_expression : IDENTIFIER
                   | INTEGER_CONSTANT
                   | CHARACTER_CONSTANT
                   | STRING_LITERAL
                   | L_PAREN expression R_PAREN
                   ;

postfix_expression : primary_expression
                   | postfix_expression L_BOX_BRACKET expression R_BOX_BRACKET
                   | postfix_expression L_PAREN argument_expression_list_opt R_PAREN
                   | postfix_expression ARROW IDENTIFIER
                   ;

argument_expression_list_opt : argument_expression_list
                             |
                             ;

argument_expression_list : assignment_expression
                         | argument_expression_list COMMA assignment_expression
                         ;

unary_expression : postfix_expression
                 | unary_operator unary_expression
                 ;

unary_operator : AMPERSAND
               | ASTERISK
               | PLUS
               | MINUS
               | EXCLAMATION
               ;

multiplicative_expression : unary_expression
                          | multiplicative_expression ASTERISK unary_expression
                          | multiplicative_expression DIV unary_expression
                          | multiplicative_expression MOD unary_expression
                          ;

additive_expression : multiplicative_expression
                    | additive_expression PLUS multiplicative_expression
                    | additive_expression MINUS multiplicative_expression
                    ;

relational_expression : additive_expression
                      | relational_expression LESS_THAN additive_expression
                      | relational_expression GREATER_THAN additive_expression
                      | relational_expression LESS_THAN_EQUAL additive_expression
                      | relational_expression GREATER_THAN_EQUAL additive_expression
                      ;

equality_expression : relational_expression
                    | equality_expression DOUBLE_EQUAL relational_expression
                    | equality_expression NOT_EQUAL relational_expression
                    ;

logical_and_expression : equality_expression
                       | logical_and_expression LOGICAL_AND equality_expression
                       ;

logical_or_expression : logical_and_expression
                      | logical_or_expression LOGICAL_OR logical_and_expression
                      ;

conditional_expression : logical_or_expression
                       | logical_or_expression QUESTION expression COLON conditional_expression
                       ;

assignment_expression : conditional_expression
                      | unary_expression ASSIGN assignment_expression
                      ;

expression : assignment_expression

/* DECLARATIONS */

declaration : type_specifier init_declarator SEMICOLON
            ;

init_declarator : declarator
                | declarator ASSIGN initializer
                ;

type_specifier : VOID
               | CHARACTER
               | INTEGER
               ;

declarator : pointer_opt direct_declarator
           ;

direct_declarator : IDENTIFIER
                  | IDENTIFIER L_BOX_BRACKET INTEGER_CONSTANT R_BOX_BRACKET
                  | IDENTIFIER L_PAREN parameter_list_opt R_PAREN
                  ;

pointer : ASTERISK
        ;

parameter_list : parameter_declaration
               | parameter_list COMMA parameter_declaration
               ;

parameter_declaration : type_specifier pointer_opt identifier_opt
                      ;

identifier_opt : IDENTIFIER
               |  
               ;

parameter_list_opt : parameter_list
                   |  
                   ;

pointer_opt : pointer
            | 
            ;

initializer : assignment_expression
            ;

/* STATEMENTS */
statement : compound_statement
          | expression_statement
          | selection_statement
          | iteration_statement
          | jump_statement
          ;

compound_statement : L_CURLY_BRACE block_item_list_opt R_CURLY_BRACE
                   ;

block_item_list : block_item
                | block_item_list block_item
                ;   

block_item_list_opt : block_item_list
                    |  
                    ;

block_item : declaration
           | statement
           ;

expression_statement : expression_opt SEMICOLON
                     ;

selection_statement : IF L_PAREN expression R_PAREN statement 
                    | IF L_PAREN expression R_PAREN statement ELSE statement
                    ;

iteration_statement : FOR L_PAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt R_PAREN statement
                    ;

jump_statement : RETURN expression_opt SEMICOLON

expression_opt : expression
                |  
                ;

/* TRANSLATION UNIT */
translation_unit : function_definition
                 | declaration
                 ;

function_definition : type_specifier declarator compound_statement
                    ;

%%
/* C++ Code for functions */

void yyerror(char *str)
{
    extern int yylineno;
    printf("Error in line %d: %s\n", yylineno, str);
}