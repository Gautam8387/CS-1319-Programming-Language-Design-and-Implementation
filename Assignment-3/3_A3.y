/* Group 03: julius-stabs-back */
/* Gautam Ahuja, Nistha Singh */ 
/* Terminal Symbols:  %token */ 
/* Non-Terminal Symbols:  %type */
/* Start Symbol: %start */

/* Declarations */
%{
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    extern int yylex(); // Lexical Analyzer generated by Flex
    void yyerror(char *s); // Error function for Bison
%}

%union {
    int ival;
    char* str;
}
/* Terminals */
%token CHARACTER ELSE FOR IF INTEGER RETURN VOID
%token <symp> IDENTIFIER
%token <ival> INTEGER_CONSTANT
%token <str> CHARACTER_CONSTANT
%token <str> STRING_LITERAL
%token L_BOX_BRACKET R_BOX_BRACKET
%token L_PAREN R_PAREN
%token L_CURLY_BRACE R_CURLY_BRACE
%token ARROW AMPERSAND ASTERISK PLUS MINUS EXCLAMATION DIV MOD
%token LESS_THAN GREATER_THAN LESS_THAN_EQUAL GREATER_THAN_EQUAL DOUBLE_EQUAL NOT_EQUAL
%token LOGICAL_AND LOGICAL_OR
%token QUESTION COLON ASSIGN SEMICOLON COMMA

/* start symbol */
%start translation_unit

/* Operators Associativity and Precedence */
/* As per the slides of module 5 */
%right ASSIGN
%right QUESTION COLON
%left LOGICAL_OR
%left LOGICAL_AND
%left NOT_EQUAL DOUBLE_EQUAL
%left LESS_THAN LESS_THAN_EQUAL GREATER_THAN GREATER_THAN_EQUAL
%left PLUS MINUS
%left ASTERISK DIV MOD



%%
/* Grammar Rules */
/* EXPRESSIONS */

primary_expression : IDENTIFIER
                    | INTEGER_CONSTANT
                    | CHARACTER_CONSTANT
                    | STRING_LITERAL
                    | L_PAREN expression R_PAREN
                    ;

postfix_expression : primary_expression
                   | postfix_expression L_BOX_BRACKET expression R_BOX_BRACKET
                   | postfix_expression L_PAREN argument_expression_list_opt R_PAREN
                   | postfix_expression ARROW IDENTIFIER
                   ;

argument_expression_list_opt : argument_expression_list
                             |  // Epsilon, do nothing
                             ;

argument_expression_list : assignment_expression
                         | argument_expression_list COMMA assignment_expression
                         ;

unary_expression : postfix_expression
                 | unary_operator unary_expression
                 ;

unary_operator : AMPERSAND
               | ASTERISK
               | PLUS
               | MINUS
               | EXCLAMATION
               ;

multiplicative_expression : unary_expression
                          | multiplicative_expression ASTERISK unary_expression
                          | multiplicative_expression DIV unary_expression
                          | multiplicative_expression MOD unary_expression
                          ;

additive_expression : multiplicative_expression
                    | additive_expression PLUS multiplicative_expression
                    | additive_expression MINUS multiplicative_expression
                    ;

relational_expression : additive_expression
                      | relational_expression LESS_THAN additive_expression
                      | relational_expression GREATER_THAN additive_expression
                      | relational_expression LESS_THAN_EQUAL additive_expression
                      | relational_expression GREATER_THAN_EQUAL additive_expression
                      ;

equality_expression : relational_expression
                    | equality_expression DOUBLE_EQUAL relational_expression
                    | equality_expression NOT_EQUAL relational_expression
                    ;

logical_and_expression : equality_expression
                       | logical_and_expression LOGICAL_AND equality_expression
                       ;

logical_or_expression : logical_and_expression
                      | logical_or_expression LOGICAL_OR logical_and_expression
                      ;

conditional_expression : logical_or_expression
                       | logical_or_expression QUESTION expression COLON conditional_expression
                       ;

assignment_expression : conditional_expression
                      | unary_expression ASSIGN assignment_expression
                      ;

expression : assignment_expression

/* DECLARATIONS */

declaration : type_specifier init_declarator SEMICOLON
            ;

init_declarator : declarator
                | declarator ASSIGN initializer
                ;

type_specifier : VOID
               | INTEGER
               | CHARACTER
               ;

declarator : pointer_opt direct_declarator
           ;

pointer_opt : pointer
            |  // Epsilon, do nothing
            ;

direct_declarator : IDENTIFIER
                  | IDENTIFIER L_BOX_BRACKET INTEGER_CONSTANT R_BOX_BRACKET
                  | IDENTIFIER L_PAREN parameter_list_opt R_PAREN
                  ;

parameter_list_opt : parameter_list
                   |  // Epsilon, do nothing
                   ;

pointer : ASTERISK
        ;

parameter_list : parameter_declaration
               | parameter_list COMMA parameter_declaration
               ;

parameter_declaration : type_specifier pointer_opt identifier_opt
                      ;

identifier_opt : IDENTIFIER
               |  // Epsilon, do nothing
               ;

initializer : assignment_expression
            ;

/* STATEMENTS */
statement : compound_statement
          | expression_statement
          | selection_statement
          | iteration_statement
          | jump_statement
          ;

compound_statement : L_CURLY_BRACE block_item_list_opt R_CURLY_BRACE
                   ;

block_item_list_opt : block_item_list
                    |  // Epsilon, do nothing
                    ;

block_item_list : block_item
                | block_item_list block_item
                ;   

block_item : declaration
           | statement
           ;

expression_statement : expression_opt SEMICOLON
                     ;

expression_opt : expression
                |  // Epsilon, do nothing
                ;

selection_statement : IF L_PAREN expression R_PAREN statement 
                    | IF L_PAREN expression R_PAREN statement ELSE statement
                    ;

iteration_statement : FOR L_PAREN expression_opt SEMICOLON expression_opt SEMICOLON expression_opt R_PAREN statement
                    ;

jump_statement : RETURN expression_opt SEMICOLON

/* Translation Unit */
translation_unit : function_definition
                 | declaration
                 ;

function_definition : type_specifier declarator compound_statement
                    ;

%%

/* C++ Code for functions */

void yyerror(char *str)
{
    extern int yylineno;
    fprintf(stderr,"%s at Line: %d \n",str, yylineno);
}