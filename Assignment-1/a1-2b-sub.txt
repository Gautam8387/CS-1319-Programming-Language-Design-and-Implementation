\subsection*{Annotate Assembly}
We have to annotate the \texttt{CONST} segment (\texttt{CONST SEGMENT} to \texttt{CONST ENDS}) and \texttt{TEXT} segment (\texttt{TEXT SEGMENT}
to \texttt{TEXT ENDS}).\\[\baselineskip]
For the \texttt{CONST} segment:
{\renewcommand\fcolorbox[4][]{\textcolor{black}{\strut#4}}
\begin{minted}[linenos, frame = single, breaklines]{nasm}
; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.21005.1
    .686P
    .XMM
    include listing.inc
    .model flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC _n1
PUBLIC _n2

CONST SEGMENT
# The CONST SEGMENT is where global and static variables are initialized. This marks the beginning of the CONST/DATA SEGMENT.
# The start of the program which defines constant integers are define as `_n1` and `_n2` with initial values `019H` (which is 25 in decimal) and `027H` (which is 39 in decimal), respectively in this segment.
_n1 DD 019H
_n2 DD 027H
CONST ENDS

PUBLIC _main
PUBLIC ??_C@_0BP@CMAHBJAF@?6The?5absoute?5difference?5is?3?5?$CFd?$AA@ ; ‘string’
EXTRN __imp__printf:PROC
EXTRN __RTC_CheckEsp:PROC
EXTRN __RTC_InitBase:PROC
EXTRN __RTC_Shutdown:PROC
; COMDAT rtc$TMZ
rtc$TMZ SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ ENDS
; COMDAT rtc$IMZ
rtc$IMZ SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ ENDS
; COMDAT ??_C@_0BP@CMAHBJAF@?6The?5absoute?5difference?5is?3?5?$CFd?$AA@

CONST SEGMENT
# the following lines define a null-terminated string that is utilized by the printf function. This string includes the text "The absolute difference is: %d," and it incorporates encoded special characters ("0aH = ’\n’ and 0aH = NULL)  and formatting placeholders.
??_C@_0BP@CMAHBJAF@?6The?5absoute?5difference?5is?3?5?$CFd?$AA@ DB 0aH, ’T’
DB ’he absoute difference is: %d’, 00H ; ‘string’
CONST ENDS
\end{minted}
}

\newpage
For the \texttt{TEXT} segment:
{\renewcommand\fcolorbox[4][]{\textcolor{black}{\strut#4}}
    \begin{minted}[linenos,frame=single, firstnumber = 36, breaklines]{nasm}
; Function compile flags: /Odtp /RTCsu /ZI
; COMDAT _main

## Program code is contained here. TEXT/CODE SEGMENT begins here.
_TEXT SEGMENT
#The following lines establish the stack frame for the `main` function. They preserve the current base pointer (ebp), set ebp to the current stack pointer (esp), and allocate space for local variables by subtracting 228 bytes from esp.
_diff$ = -32 ; size = 4 # The offset for the variable 'diff', with its address at ebp-32.
_num2$ = -20 ; size = 4 # The offset for the variable 'num2', with its address at ebp-20.
_num1$ = -8 ; size = 4 # The offset for the variable 'num1', with its address at ebp-8.
_main PROC ; COMDAT
# Function main code starts here.

; 5 : int main() {
# Save the current frame pointer (ebp) on the stack to preserve the frame information for the caller. Decrement esp by 4 bytes.
push ebp 

# Set ebp as the new frame pointer, pointing to the current stack top (esp).
mov ebp, esp 
# Reserve 228 bytes (4 * 57) (000000e4H) of space on the stack for local and temporary variables. Decrement esp by 228 bytes.
sub esp, 228 ; 

# Save registers ebx (not being used in this function), esi (index register; here a temporary register for system correctness check), and edi (used by ’rep stosd’ in order to refer to the the stack memory location) on the stack for later use. Decrement esp by 4 bytes for each register. 
push ebx
push esi
push edi

# Load the effective address of memory at offset -228 from ebp into edi.
lea edi, DWORD PTR [ebp-228]
# Load the constant value 57 into ecx, which will serve as a loop counter.
mov ecx, 57 ; 00000039H 
# Initialize eax with a garbage value.
mov eax, -858993460 ; ccccccccH
#  Use 'rep stosd' to fill 228 bytes of local memory with the garbage value.
rep stosd # To initialize the reserved 228-byte local memory, the code loops 57 times. During each iteration, it advances by 4 bytes and assigns the initial garbage value stored in eax to that location, resulting in 57 segments of 4-byte garbage values in the local memory.

; 6 : int num1, num2, diff;
; 7 :
; 8 : num1 = n1;
# Load the value of variable n1 
mov eax, DWORD PTR _n1 
mov DWORD PTR _num1$[ebp], eax 

; 9 : num2 = n2;
# Load the value of variable n2
mov eax, DWORD PTR _n2  
mov DWORD PTR _num2$[ebp], eax 

; 10 : diff = num1 - num2; 
mov eax, DWORD PTR _num1$[ebp] # This line loads the value of the variable num1 from memory into the EAX register.
sub eax, DWORD PTR _num2$[ebp] # This line subtracts the value of the variable num2 from the value in the EAX register, effectively calculating num1 - num2 and storing the result in the EAX register.
mov DWORD PTR _diff$[ebp], eax # Loads value of the subtraction stored in EAX register to the diff variable.

; 11 :
; 12 : if (num1 - num2 < 0) 
mov eax, DWORD PTR _num1$[ebp] #This line loads the value of the variable num1 from memory into the EAX register.
sub eax, DWORD PTR _num2$[ebp] #This line subtracts the value of the variable num2 from the value in the EAX register, effectively calculating num1 - num2 and storing the result in the EAX register.
jns SHORT $LN1@main #This is a conditional jump instruction. It checks the sign flag (SF) in the EFLAGS register. If the sign flag is not set (i.e., the result of the subtraction is greater than or equal to zero), it will jump to the label $LN1@main.

; 13 : diff = -diff;
mov eax, DWORD PTR _diff$[ebp] #Load the value of the variable `diff` into the EAX register.
neg eax #Negate the value in the EAX register (essentially calculating `-diff`).
mov DWORD PTR _diff$[ebp], eax #Store the negated value back into the variable `diff`.

$LN1@main: This is a label, indicating the beginning of a code section which will be executed when the result of subtraction is greater than or equal to zero.

; 14 :
\end{minted}
}

\newpage
{\renewcommand\fcolorbox[4][]{\textcolor{black}{\strut#4}}
    \begin{minted}[linenos,frame=single, firstnumber = 84, breaklines]{nasm}
; 15 : printf("\nThe absoute difference is: %d", diff);
mov esi, esp # Save esp (stack pointer) to esi.
mov eax, DWORD PTR _diff$[ebp]  #Load the value at _diff$[ebp] = ebp-32 to eax. eax now holds the diff value between num1 and num2. 
push eax #Save eax on the stack memory. This is parameter 2 for printf. esp gets decremented by 4.
push OFFSET ??_C@_0BP@CMAHBJAF@?6The?5absoute?5difference?5is?3?5?$CFd?$AA@ #Push the string constant ("\nThe absolute difference is: %d") that was defined in a variable in CONST/DATA Segment to stack memory using its offset. This is parameter 1 for printf. esp gets decremented by 4.
call DWORD PTR __imp__printf #Call the externally defined and previously imported procedure:__imp__printf. It gets two parameters on top of stack i.e. the string constant("\nThe absolute difference is: %d") and the value in eax (the variable diff) in that order using LIFO. This pops out the values in eax and the OFFSET out of the stack memory. However, esp does not get incremented. we have to manually increment it.
add esp, 8 #esp is incremented by 8 manually to realize pop of two parameters passed before
call to the procedure: __imp__printf.
cmp esi, esp # Compare esp with esi(i.e. the value of esp before calling printf()). This will set a compare bit. 
call __RTC_CheckEsp # Check the compare bit to confirm that esp matches its value before function call to printf(). This is a system check for correctness. 

; 16 :
; 17 : return 0;
xor eax, eax # eax = eax ^ eax = 0. A one cycle instruction to clear the accumulator register eax. 
; 18 : }

pop edi # Restore edi from the stack memory. esp gets incremented by 4.
pop esi #Restore esi from the stack memory. esp gets incremented by 4.
pop ebx # Restore ebx from the stack memory. esp gets incremented by 4.
add esp, 228 ; 000000e4H  #Release 228 bytes of the frame of main in stack memory that was reserved for local and temporary variables. esp gets incremented by 228 bytes. 
cmp ebp, esp Compare esp with ebp(i.e. the value of esp before frame of main was reserved for local and temporary variables in stack memory).
call __RTC_CheckEsp #Check the compare bit to confirm that esp matches its value before operating upon the instructions within the main function. This is a system check for correctness.
mov esp, ebp # Restore the value of esp from ebp. 
pop ebp 1 # Restore ebp(i.e. the frame of the parent (caller) function) from the stack memory.

ret 0
# Return 0. Control returns through indirect jump.
_main ENDP
# Function main code ends here
_TEXT ENDS
# TEXT SEGMENT ends here.

END
    \end{minted}
    }


