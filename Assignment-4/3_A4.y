/* Group 03: julius-stabs-back */
/* Gautam Ahuja, Nistha Singh */ 
/* Terminal Symbols:  %token */ 
/* Non-Terminal Symbols:  %type */
/* Start Symbol: %start */

/* Declarations */
%{
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h> 
    #include "3_A4_translator.h"
    extern int yylex();     // Lexical Analyzer generated by Flex
    void yyerror(char *s);  // Error function for Bison
    extern char* yytext;    // yytext declaration
    extern var_type_stack var_type;
    extern string_list* string_head;
%}

%union {
    char* intval;
    char* strval;
    char* charval;
    char* u_op;
    int count;
    char UNIARY_OPERATOR;
    struct symboltableentry* sym_entry;
    struct symboltype* sym_type;
    struct expression* expr;
    struct statement* stmt;
};

/* start symbol */
%start translation_unit

/* Terminals */
%token CHARACTER                        // "char"
%token ELSE                             // "else"  
%token FOR                              // "for"    
%token IF                               // "if"
%token INTEGER                          // "int"
%token RETURN                           // "return"
%token VOID                             // "void"
%token L_BOX_BRACKET                    // "["
%token R_BOX_BRACKET                    // "]"
%token L_PARENTHESIS                    // "("
%token R_PARENTHESIS                    // ")"
%token L_CURLY_BRACE                    // "{"
%token R_CURLY_BRACE                    // "}"
%token ARROW                            // "->"
%token AMPERSAND                        // "&"
%token ASTERISK                         // "*"
%token PLUS                             // "+"  
%token MINUS                            // "-"
%token EXCLAMATION                      // "!"
%token DIV                              // "/"
%token MOD                              // "%"
%token LESS_THAN                        // "<"
%token GREATER_THAN                     // ">" 
%token LESS_THAN_EQUAL                  // "<="
%token GREATER_THAN_EQUAL               // ">="
%token IS_EQUAL                         // "=="
%token NOT_EQUAL                        // "!="
%token LOGICAL_AND                      // "&&"
%token LOGICAL_OR                       // "||"
%token QUESTION                         // "?"
%token COLON                            // ":"
%token ASSIGN                           // "="
%token SEMICOLON                        // ";"
%token COMMA                            // ","
%token PUNCTUATOR
%token WS

%token <sym_entry> IDENTIFIER                       
%token <intval> INTEGER_CONSTANT
%token <charval> CHARACTER_CONSTANT
%token <strval> STRING_LITERAL

/* Operators Associativity and Precedence */
/* As per the slides of module 5 */
%right ASSIGN
%right QUESTION COLON
%left LOGICAL_OR
%left LOGICAL_AND
%left NOT_EQUAL IS_EQUAL
%left LESS_THAN LESS_THAN_EQUAL GREATER_THAN GREATER_THAN_EQUAL
%left PLUS MINUS
%left ASTERISK DIV MOD

/* Non-Terminals */
//Expressions
%type <expr> primary_expression expression postfix_expression unary_expression multiplicative_expression additive_expression relational_expression
%type <expr> constant equality_expression logical_and_expression logical_or_expression conditional_expression assignment_expression expression_statement
%type <expr> statement compound_statement selection_statement iteration_statement jump_statement block_item block_item_list block_item_list_opt 
%type <sym_entry> initializer direct_declarator init_declarator declarator identifier_opt
%type <u_op> pointer_opt pointer unary_operator
%type <count> argument_expression_list_opt argument_expression_list

%%
/* Grammar Rules */

/* EXPRESSIONS */
primary_expression : IDENTIFIER {
                            // new expression
                            $$ = create_expression();
                            $$->loc = $1;
                            printf("primary-expression\n");
                        }
                   | constant {
                            printf("primary-expression\n");
                            $$ = $1;
                        }
                   | STRING_LITERAL {
                            $$ = create_expression();
                            // generate a temporary entry for the string literal
                            $$->loc = gentemp(create_symboltype(TYPE_PTR, 1, NULL), $1);
                            $$->loc->type->ptr = create_symboltype(TYPE_CHAR, 1, NULL);
                            // Store the String in linekd list of strings
                            ll_insert(string_head, $1);
                            // emit the results, set size of linked list
                            printf("primary-expression\n");
                        }
                   | L_PARENTHESIS expression R_PARENTHESIS {
                            $$ = $2;
                            printf("primary-expression\n");
                        }
                   ;

constant : INTEGER_CONSTANT {
                $$ = create_expression();
                // generate a temporary entry for the integer constant
                $$->loc = gentemp(create_symboltype(TYPE_INT, 1, NULL), $1);
                // emit the results

            }
         | CHARACTER_CONSTANT{
                $$ = create_expression();
                // generate a temporary entry for the character constant
                $$->loc = gentemp(create_symboltype(TYPE_CHAR, 1, NULL), $1);
                // emit the results
            }
         ;

postfix_expression : primary_expression {
                            $$ = $1;
                            $$->arrBase = $1->loc;  // set the array base to the location of the primary expression
                            printf("postfix-expression\n");
                        }
                   | postfix_expression L_BOX_BRACKET expression R_BOX_BRACKET {
                            $$ = create_expression();
                            // set flag to array
                            $$->isArray = true;
                            $$->loc = $3->loc;
                            // set the array base to the location of the postfix expression
                            $$->arrBase = $1->loc;
                            printf("postfix-expression\n");
                        }
                   | postfix_expression L_PARENTHESIS argument_expression_list_opt R_PARENTHESIS {
                            // This is a function call
                            $$ = create_expression();
                            // check if the postfix expression points to a function symbol table entry
                            if($1->loc->next != NULL){
                                // generate temp of type of return value of function.
                                // f# = call function, para#
                                $$->loc = gentemp($1->loc->next->_retVal, NULL);
                                $$->arrBase = $$->loc;
                                // emit the code for function call. Paramter count is in argument_expression_list_opt

                            }
                            // function not defined
                            else{
                                char* temp = "Function not defined for ";
                                sprintf(temp, "%s\n", $1->loc->name);
                                yyerror(temp);
                            }
                            printf("postfix-expression\n");
                        }
                   | postfix_expression ARROW IDENTIFIER {
                            // we do not have any structs or classes in our language.
                            $$ = $1;
                            printf("postfix-expression\n");
                        }
                   ;

argument_expression_list_opt : argument_expression_list {
                                    // this is parameter list
                                    $$ = $1;                                    
                                }
                             | {
                                    $$ = 0;
                                }
                             ;

argument_expression_list : assignment_expression {
                                // this is single parameter
                                $$ = 1;
                                // emit the code for parameter
                                printf("argument-expression-list\n");
                            }
                         | argument_expression_list COMMA assignment_expression {
                                // this is a list of parameters
                                $$ = $1 + 1;
                                // emit the code for parameter
                                printf("argument-expression-list\n");
                            }
                         ;

unary_expression : postfix_expression {
                        $$ = $1;
                        printf("unary-expression\n");
                    }
                 | unary_operator unary_expression {
                        // this is rule used for unary operators preceding a postfix expression
                        $$ = create_expression();
                        
                        // check the unary_operator type
                        if(strcmp($1, "&") == 0){
                            // an operator is refering to a variable address. It has to be a pointer
                            // struct symboltype* temp = create_symboltype(TYPE_PTR, 1, NULL);
                            $$->arrBase = gentemp(create_symboltype(TYPE_PTR, 1, NULL), NULL);
                            $$->arrBase->type->ptr = $2->arrBase->type;
                            // emit the code for refering
                        }

                        else if(strcmp($1, "*") == 0){
                            // an operator is dereferencing a pointer. It has returned a value
                            $$->loc = gentemp($2->arrBase->type->ptr, NULL);
                            $$->isPtr = true;
                            $$->arrBase = $2->arrBase;
                            // emit the code for dereferencing
                        }

                        else if(strcmp($1, "+") == 0){
                            // unary plus is normal plus, propagate the type
                            $$ = $2;
                        }

                        else if(strcmp($1, "-") == 0){
                            // unary minus is flipping the sign, propagate the results
                            struct symboltype* temp = create_symboltype($2->arrBase->type->type, 1, NULL);
                            $$->arrBase = gentemp(temp, NULL);
                            // emit the code for unary expression

                        }
                        else if(strcmp($1, "!") == 0){
                            // unary not is flipping the boolean. Reverse the list of true and false
                            if($2->isBool){
                                // flip the lists
                                $$->trueList = $2->falseList;
                                $$->falseList = $2->trueList;
                                $$->isBool = true;
                                $$->arrBase = $2->arrBase;
                                $$->loc = $2->loc;
                            }
                            else{
                                // wrong type for unary not
                                char* temp = "Boolean Expressions not allowed\n";
                                yyerror(temp);
                            }
                        }
                        printf("unary-expression\n");
                    }
                 ;

unary_operator : AMPERSAND {
                        $$ = "&";
                        printf("unary-operator\n");
                    }
               | ASTERISK {
                        $$ = "*";
                        printf("unary-operator\n");
                    }
               | PLUS {
                        $$ = "+";
                        printf("unary-operator\n");
                    }
               | MINUS {
                        $$ = "-";
                        printf("unary-operator\n");
                    }
               | EXCLAMATION {
                        $$ = "!";
                        printf("unary-operator\n");
                    }
               ;

multiplicative_expression : unary_expression {
                                    struct expression* temp = create_expression();
                                    // check if the expression is a pointer
                                    if($1->isPtr){
                                        // copy the loation of expression to temp
                                        temp->loc = $1->loc;
                                    } else if($1->isArray){    // check if array
                                        // new temporary entry for array in current symbol table
                                        $$->loc = gentemp($1->loc->type, $1->loc->initial_value);
                                        // emit the code for array

                                        // reset array flag
                                        $1->isArray = false;
                                    }else{
                                        $$ = $1;
                                        $$->loc = $1->arrBase;
                                    }
                                    printf("multiplicative-expression\n");
                                }
                          | multiplicative_expression ASTERISK unary_expression {printf("multiplicative-expression\n");}
                          | multiplicative_expression DIV unary_expression {printf("multiplicative-expression\n");}
                          | multiplicative_expression MOD unary_expression {printf("multiplicative-expression\n");}
                          ;

additive_expression : multiplicative_expression {
                            $$ = $1;
                            printf("additive-expression\n");
                        }
                    | additive_expression PLUS multiplicative_expression {printf("additive-expression\n");}
                    | additive_expression MINUS multiplicative_expression {printf("additive-expression\n");}
                    ; 

relational_expression : additive_expression {
                                $$ = $1;
                                printf("relational-expression\n");
                            }
                      | relational_expression LESS_THAN additive_expression {printf("relational-expression\n");}
                      | relational_expression GREATER_THAN additive_expression {printf("relational-expression\n");}
                      | relational_expression LESS_THAN_EQUAL additive_expression {printf("relational-expression\n");}
                      | relational_expression GREATER_THAN_EQUAL additive_expression {printf("relational-expression\n");}
                      ;

equality_expression : relational_expression {
                            $$ = $1;
                            printf("equality-expression\n");
                        }
                    | equality_expression IS_EQUAL relational_expression {printf("equality-expression\n");}
                    | equality_expression NOT_EQUAL relational_expression {printf("equality-expression\n");}
                    ;

logical_and_expression : equality_expression {
                                $$ = $1;
                                printf("logical-AND-expression\n");
                            }
                       | logical_and_expression LOGICAL_AND equality_expression {printf("logical-AND-expression\n");}
                       ;

logical_or_expression : logical_and_expression {
                                $$=$1;
                                printf("logical-OR-expression\n");
                            }
                      | logical_or_expression LOGICAL_OR logical_and_expression {printf("logical-OR-expression\n");}
                      ;

conditional_expression : logical_or_expression {
                                $$ = $1;
                                printf("conditional-expression\n");
                            }
                       | logical_or_expression QUESTION expression COLON conditional_expression {printf("conditional-expression\n");}
                       ;

assignment_expression : conditional_expression {
                                $$ = $1;
                                printf("assignment-expression\n");
                            }
                      | unary_expression ASSIGN assignment_expression {printf("assignment-expression\n");}
                      ;

expression : assignment_expression {printf("expression\n");}
           ;

/* DECLARATIONS */

declaration : type_specifier init_declarator SEMICOLON {
                    // Reducing function_definition to declaration, move the new symbol table pointer NULL.
		            new_ST = NULL;
                    printf("declaration\n");
                }
            ;

init_declarator : declarator {
                        // check if the current table is global or not
                        if (currST == globalST){
                            if($1->type->type == TYPE_INT || $1->type->type == TYPE_CHAR || $1->type->type == TYPE_PTR || $1->type->type == TYPE_ARRAY){
                                // assign initial value to the symbol table entry
                                $1->initial_value = "0";
                            }
                        }
                        printf("init-declarator\n");
                    }
                | declarator ASSIGN initializer {
                        // check if a value exist in initializer
                        if($3 != NULL){
                                // assign value to the symbol table entry
                                $1->initial_value = $3->initial_value;
                                // update type of initializer
                                update_type($3, $1->type);
                            }
                        printf("init-declarator\n"); 
                    }
                ;

type_specifier : VOID {
                        printf("type-specifier\n");
                        push(&var_type, TYPE_VOID);
                    }
               | CHARACTER {
                        printf("type-specifier\n");
                        push(&var_type, TYPE_CHAR);
                    }
               | INTEGER {
                        printf("type-specifier\n");
                        push(&var_type, TYPE_INT);
                    }
               ;

declarator : pointer_opt direct_declarator {
                    if($1 != NULL){
                        struct symboltype* temp = create_symboltype(TYPE_PTR, 1, NULL);
                        if($2->next == NULL){
                            // it is an Array
                            temp->ptr = $2->type;
                            update_type($2, temp);
                        }
                        else{
                            // it is a function
                            temp->ptr = $2->next->_retVal;
                            $2->next->_retVal = temp;
                        }
                    }
                    $$ = $2;
                    printf("declarator\n");
                }
           ;

pointer_opt : pointer {$$ = $1;}
            | {$$ = NULL;}
            ;

direct_declarator : IDENTIFIER {
                            // new symbol table entry
                            $1 = lookup(currST, $1->name);
                            // typeentry
                            update_type($1, create_symboltype(pop(&var_type), 1, NULL));
                            $$ = $1;
                            printf("direct-declarator\n");
                        }
                  | IDENTIFIER L_BOX_BRACKET INTEGER_CONSTANT R_BOX_BRACKET {
                            $1 = lookup(currST, $1->name);
                            // type entry
                            update_type($1, create_symboltype(pop(&var_type), 1, NULL));
                            // set array flag
                            update_type($1, create_symboltype(TYPE_ARRAY, atoi($3), $1->type));
                            $$ = $1;
                            printf("direct-declarator\n");
                        }
                  | IDENTIFIER L_PARENTHESIS parameter_list_opt R_PARENTHESIS {printf("direct-declarator\n");}
                  ;

parameter_list_opt : parameter_list
                   | 
                   ;

pointer : ASTERISK {
                $$ = "*";
                printf("pointer\n");
            }
        ;

parameter_list : parameter_declaration {printf("parameter-list\n");}
               | parameter_list COMMA parameter_declaration {printf("parameter-list\n");}
               ;

parameter_declaration : type_specifier pointer_opt identifier_opt {printf("parameter-declaration\n");}
                      ;

identifier_opt : IDENTIFIER
               | 
               ;

initializer : assignment_expression {
                    $$ = $1->loc;
                    printf("initializer\n");
                }
            ;

/* STATEMENTS */
statement : compound_statement {printf("statement\n");}
          | expression_statement {printf("statement\n");}
          | selection_statement {printf("statement\n");}
          | iteration_statement {printf("statement\n");}
          | jump_statement {printf("statement\n");}
          ;

compound_statement : L_CURLY_BRACE block_item_list_opt R_CURLY_BRACE {printf("compound-statement\n");}
                   ;

block_item_list_opt : block_item_list
                    | 
                    ;

block_item_list : block_item {printf("block-item-list\n");}
                | block_item_list block_item {printf("block-item-list\n");}
                ;   

block_item : declaration {printf("block-item\n");}
           | statement {printf("block-item\n");}
           ;

expression_statement : expression_opt SEMICOLON {printf("expression-statement\n");}
                     ;

expression_opt : expression
               |
               ;

selection_statement : IF L_PARENTHESIS expression R_PARENTHESIS statement {printf("selection-statement\n");}
                    | IF L_PARENTHESIS expression R_PARENTHESIS statement ELSE statement {printf("selection-statement\n");}
                    ;

iteration_statement : FOR L_PARENTHESIS expression_opt SEMICOLON expression_opt SEMICOLON expression_opt R_PARENTHESIS statement {printf("iteration-statement\n");}
                    ;

jump_statement : RETURN expression_opt SEMICOLON {printf("jump-statement\n");}
               ;

/* TRANSLATION UNIT */
translation_unit : external_declaration {printf("translation-unit\n");}
                 | translation_unit external_declaration {printf("translation-unit\n");}
                 ;

external_declaration : declaration {printf("external-declaration\n");}
                     | function_definition {printf("external-declaration\n");}
                     ;

function_definition : type_specifier declarator compound_statement {printf("function-definition\n");}
                    ;

%%
/* C Code for functions */

void yyerror(char *s) {
    printf("Error: %s on '%s'\n", s, yytext);
}