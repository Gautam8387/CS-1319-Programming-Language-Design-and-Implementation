/* Group 03: julius-stabs-back */
/* Gautam Ahuja, Nistha Singh */ 
/* Terminal Symbols:  %token */ 
/* Non-Terminal Symbols:  %type */
/* Start Symbol: %start */

/* Declarations */
%{
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h> 
    #include "3_A4_translator.h"
    extern int yylex();     // Lexical Analyzer generated by Flex
    void yyerror(char *s);  // Error function for Bison
    extern char* yytext;    // yytext declaration
    extern var_type_stack var_type;
    extern string_list* string_head;
%}

%union {
    char* intval;
    char* strval;
    char* charval;
    char* u_op;
    int count;
    int instr_no;
    char UNIARY_OPERATOR;
    struct symboltableentry* sym_entry;
    struct symboltype* sym_type;
    struct expression* expr;
    struct statement* stmt;
};

/* start symbol */
%start translation_unit

/* Terminals */
%token CHARACTER                        // "char"
%token ELSE                             // "else"  
%token FOR                              // "for"    
%token IF                               // "if"
%token INTEGER                          // "int"
%token RETURN                           // "return"
%token VOID                             // "void"
%token L_BOX_BRACKET                    // "["
%token R_BOX_BRACKET                    // "]"
%token L_PARENTHESIS                    // "("
%token R_PARENTHESIS                    // ")"
%token L_CURLY_BRACE                    // "{"
%token R_CURLY_BRACE                    // "}"
%token ARROW                            // "->"
%token AMPERSAND                        // "&"
%token ASTERISK                         // "*"
%token PLUS                             // "+"  
%token MINUS                            // "-"
%token EXCLAMATION                      // "!"
%token DIV                              // "/"
%token MOD                              // "%"
%token LESS_THAN                        // "<"
%token GREATER_THAN                     // ">" 
%token LESS_THAN_EQUAL                  // "<="
%token GREATER_THAN_EQUAL               // ">="
%token IS_EQUAL                         // "=="
%token NOT_EQUAL                        // "!="
%token LOGICAL_AND                      // "&&"
%token LOGICAL_OR                       // "||"
%token QUESTION                         // "?"
%token COLON                            // ":"
%token ASSIGN                           // "="
%token SEMICOLON                        // ";"
%token COMMA                            // ","
%token PUNCTUATOR
%token WS

%token <sym_entry> IDENTIFIER                       
%token <intval> INTEGER_CONSTANT
%token <charval> CHARACTER_CONSTANT
%token <strval> STRING_LITERAL

/* Operators Associativity and Precedence */
/* As per the slides of module 5 */
%right ASSIGN
%right QUESTION COLON
%left LOGICAL_OR
%left LOGICAL_AND
%left NOT_EQUAL IS_EQUAL
%left LESS_THAN LESS_THAN_EQUAL GREATER_THAN GREATER_THAN_EQUAL
%left PLUS MINUS
%left ASTERISK DIV MOD

/* Non-Terminals */
//Expressions
%type <expr> primary_expression expression postfix_expression unary_expression multiplicative_expression 
%type <expr> additive_expression relational_expression constant equality_expression logical_and_expression 
%type <expr> logical_or_expression conditional_expression assignment_expression expression_statement expression_opt
%type <stmt> statement compound_statement selection_statement iteration_statement jump_statement block_item block_item_list block_item_list_opt 
%type <sym_entry> initializer direct_declarator init_declarator declarator identifier_opt
%type <u_op> pointer_opt pointer unary_operator
%type <count> argument_expression_list_opt argument_expression_list
%type <instr_no> N

%%
/* Grammar Rules */

/* EXPRESSIONS */
primary_expression : IDENTIFIER {
                            // new expression
                            $$ = create_expression();
                            $$->loc = $1;
                            printf("primary-expression\n");
                        }
                   | constant {
                            printf("primary-expression\n");
                            $$ = $1;
                        }
                   | STRING_LITERAL {
                            $$ = create_expression();
                            // generate a temporary entry for the string literal
                            $$->loc = gentemp(create_symboltype(TYPE_PTR, 1, NULL), $1);
                            $$->loc->type->ptr = create_symboltype(TYPE_CHAR, 1, NULL);
                            // Store the String in linekd list of strings
                            ll_insert(string_head, $1);
                            // emit the results, set size of linked list
                            emit(OP_ASSIGN_STR, $1, NULL, $$->loc->name);
                            printf("primary-expression\n");
                        }
                   | L_PARENTHESIS expression R_PARENTHESIS {
                            $$ = $2;
                            printf("primary-expression\n");
                        }
                   ;

constant : INTEGER_CONSTANT {
                $$ = create_expression();
                // generate a temporary entry for the integer constant
                $$->loc = gentemp(create_symboltype(TYPE_INT, 1, NULL), $1);
                // emit the results
                emit(OP_ASSIGN, $1, NULL, $$->loc->name);

            }
         | CHARACTER_CONSTANT{
                $$ = create_expression();
                // generate a temporary entry for the character constant
                $$->loc = gentemp(create_symboltype(TYPE_CHAR, 1, NULL), $1);
                // emit the results
                emit(OP_ASSIGN, $1, NULL, $$->loc->name);
            }
         ;

postfix_expression : primary_expression {
                            $$ = $1;
                            $$->arrBase = $1->loc;  // set the array base to the location of the primary expression
                            printf("postfix-expression\n");
                        }
                   | postfix_expression L_BOX_BRACKET expression R_BOX_BRACKET {
                            $$ = create_expression();
                            // set flag to array
                            $$->isArray = true;
                            $$->loc = $3->loc;
                            // set the array base to the location of the postfix expression
                            $$->arrBase = $1->loc;
                            printf("postfix-expression\n");
                        }
                   | postfix_expression L_PARENTHESIS argument_expression_list_opt R_PARENTHESIS {
                            // This is a function call
                            $$ = create_expression();
                            // check if the postfix expression points to a function symbol table entry
                            if($1->loc->next != NULL){
                                // generate temp of type of return value of function.
                                // f# = call function, para#
                                $$->loc = gentemp($1->loc->next->_retVal, NULL);
                                $$->arrBase = $$->loc;
                                // emit the code for function call. Paramter count is in argument_expression_list_opt
                                // convert $3 to string
                                char intTOstr[10];
                                sprintf(intTOstr, "%d", $3);
                                emit(OP_CALL, $$->loc->name, $1->loc->name, intTOstr);
                            }
                            // function not defined
                            else{
                                char* temp = "Function not defined for ";
                                sprintf(temp, "%s\n", $1->loc->name);
                                yyerror(temp);
                            }
                            printf("postfix-expression\n");
                        }
                   | postfix_expression ARROW IDENTIFIER {
                            // we do not have any structs or classes in our language.
                            $$ = $1;
                            printf("postfix-expression\n");
                        }
                   ;

argument_expression_list_opt : argument_expression_list {
                                    // this is parameter list
                                    $$ = $1;                                    
                                }
                             | {
                                    $$ = 0;
                                }
                             ;

argument_expression_list : assignment_expression {
                                // this is single parameter
                                $$ = 1;
                                // emit the code for parameter
                                emit(OP_PARAM, $1->loc->name, NULL, NULL);
                                printf("argument-expression-list\n");
                            }
                         | argument_expression_list COMMA assignment_expression {
                                // this is a list of parameters
                                $$ = $1 + 1;
                                // emit the code for parameter
                                emit(OP_PARAM, $3->loc->name, NULL, NULL);
                                printf("argument-expression-list\n");
                            }
                         ;

unary_expression : postfix_expression {
                        $$ = $1;
                        printf("unary-expression\n");
                    }
                 | unary_operator unary_expression {
                        // this is rule used for unary operators preceding a postfix expression
                        $$ = create_expression();
                        
                        // check the unary_operator type
                        if(strcmp($1, "&") == 0){
                            // an operator is refering to a variable address. It has to be a pointer
                            // struct symboltype* temp = create_symboltype(TYPE_PTR, 1, NULL);
                            $$->arrBase = gentemp(create_symboltype(TYPE_PTR, 1, NULL), NULL);
                            $$->arrBase->type->ptr = $2->arrBase->type;
                            // emit the code for refering
                            emit(OP_ASSIGN_AMPER, $$->arrBase->name, $2->arrBase->name, NULL);
                        }

                        else if(strcmp($1, "*") == 0){
                            // an operator is dereferencing a pointer. It has returned a value
                            $$->loc = gentemp($2->arrBase->type->ptr, NULL);
                            $$->isPtr = true;
                            $$->arrBase = $2->arrBase;
                            // emit the code for dereferencing
                            emit(OP_ASSIGN_ASTERISK, $$->loc->name, $2->arrBase->name, NULL);
                        }

                        else if(strcmp($1, "+") == 0){
                            // unary plus is normal plus, propagate the type
                            $$ = $2;
                        }

                        else if(strcmp($1, "-") == 0){
                            // unary minus is flipping the sign, propagate the results
                            struct symboltype* temp = create_symboltype($2->arrBase->type->type, 1, NULL);
                            $$->arrBase = gentemp(temp, NULL);
                            // emit the code for unary expression
                            emit(OP_UMINUS, $$->arrBase->name, $2->arrBase->name, NULL);

                        }
                        else if(strcmp($1, "!") == 0){
                            // unary not is flipping the boolean. Reverse the list of true and false
                            if($2->isBool){
                                // flip the lists
                                $$->trueList = $2->falseList;
                                $$->falseList = $2->trueList;
                                $$->isBool = true;
                                $$->arrBase = $2->arrBase;
                                $$->loc = $2->loc;
                            }
                            else{
                                // wrong type for unary not
                                char* temp = "Boolean Expressions not allowed\n";
                                yyerror(temp);
                            }
                        }
                        printf("unary-expression\n");
                    }
                 ;

unary_operator : AMPERSAND {
                        $$ = "&";
                        printf("unary-operator\n");
                    }
               | ASTERISK {
                        $$ = "*";
                        printf("unary-operator\n");
                    }
               | PLUS {
                        $$ = "+";
                        printf("unary-operator\n");
                    }
               | MINUS {
                        $$ = "-";
                        printf("unary-operator\n");
                    }
               | EXCLAMATION {
                        $$ = "!";
                        printf("unary-operator\n");
                    }
               ;

multiplicative_expression : unary_expression {
                                    struct expression* temp = create_expression();
                                    // check if the expression is a pointer
                                    if($1->isPtr){
                                        // copy the loation of expression to temp
                                        temp->loc = $1->loc;
                                    } else if($1->isArray){    // check if array
                                        // new temporary entry for array in current symbol table
                                        $$->loc = gentemp($1->loc->type, $1->loc->initial_value);
                                        // emit the code for array
                                        emit(OP_ASSIGN_BOX, $$->loc->name, $1->arrBase->name, $1->loc->initial_value);
                                        // reset array flag
                                        $1->isArray = false;
                                    }else{
                                        $$ = $1;
                                        $$->loc = $1->arrBase;
                                    }
                                    printf("multiplicative-expression\n");
                                }
                          | multiplicative_expression ASTERISK unary_expression {
                                    // check if both expressions are of same type or need conversion
                                    if(typecheck($1->loc->type, $3->arrBase->type)){
                                        $$ = create_expression();
                                        // t# = a*b; of type of a
                                        $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                        // emit the code for multiplication
                                        emit(OP_MULT, $1->loc->name, $3->arrBase->name, $$->loc->name);
                                    }
                                    else{
                                        // conversion ???
                                        yyerror("Type mismatch in multiplicative MULT expression\n");
                                    }
                                    printf("multiplicative-expression\n");
                                }
                          | multiplicative_expression DIV unary_expression {
                                    if(typecheck($1->loc->type, $3->arrBase->type)){
                                        $$ = create_expression();
                                        // t# = a/b; of type of a
                                        $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                        // emit the code for division
                                        emit(OP_DIV, $1->loc->name, $3->arrBase->name, $$->loc->name);
                                    }
                                    else{
                                        // conversion ???
                                        yyerror("Type mismatch in multiplicative DIV expression\n");
                                    }
                                    printf("multiplicative-expression\n");
                                }
                          | multiplicative_expression MOD unary_expression {
                                    if(typecheck($1->loc->type, $3->arrBase->type)){
                                        $$ = create_expression();
                                        // t# = a%b; of type of a
                                        $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                        // emit the code for modulus
                                        emit(OP_MOD, $1->loc->name, $3->arrBase->name, $$->loc->name);  
                                    }
                                    else{
                                        // conversion ???
                                        yyerror("Type mismatch in multiplicative MOD expression\n");
                                    }
                                    printf("multiplicative-expression\n");
                                }
                          ;

additive_expression : multiplicative_expression {
                            $$ = $1;
                            printf("additive-expression\n");
                        }
                    | additive_expression PLUS multiplicative_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $$ = create_expression();
                                // t# = a+b; of type of a
                                $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                // emit the code for addition
                                emit(OP_PLUS, $1->loc->name, $3->loc->name, $$->loc->name);
                            }
                            else{
                                // conversion ???
                                yyerror("Type mismatch in additive PLUS expression\n");
                            }
                            printf("additive-expression\n");
                        }
                    | additive_expression MINUS multiplicative_expression {
                            if(typecheck($1->loc->type, $3->loc->type)){
                                $$ = create_expression();
                                // t# = a-b; of type of a
                                $$->loc = gentemp(create_symboltype($1->loc->type->type, 1, NULL), NULL);
                                // emit the code for subtraction
                                emit(OP_MINUS, $1->loc->name, $3->loc->name, $$->loc->name);
                            }
                            else{
                                // conversion ???
                                yyerror("Type mismatch in additive MINUS expression\n");
                            }
                            printf("additive-expression\n");
                        }
                    ; 

relational_expression : additive_expression {
                                $$ = $1;
                                printf("relational-expression\n");
                            }
                      | relational_expression LESS_THAN additive_expression {printf("relational-expression\n");}
                      | relational_expression GREATER_THAN additive_expression {printf("relational-expression\n");}
                      | relational_expression LESS_THAN_EQUAL additive_expression {printf("relational-expression\n");}
                      | relational_expression GREATER_THAN_EQUAL additive_expression {printf("relational-expression\n");}
                      ;

equality_expression : relational_expression {
                            $$ = $1;
                            printf("equality-expression\n");
                        }
                    | equality_expression IS_EQUAL relational_expression {printf("equality-expression\n");}
                    | equality_expression NOT_EQUAL relational_expression {printf("equality-expression\n");}
                    ;

logical_and_expression : equality_expression {
                                $$ = $1;
                                printf("logical-AND-expression\n");
                            }
                       | logical_and_expression LOGICAL_AND equality_expression {printf("logical-AND-expression\n");}
                       ;

logical_or_expression : logical_and_expression {
                                $$=$1;
                                printf("logical-OR-expression\n");
                            }
                      | logical_or_expression LOGICAL_OR logical_and_expression {printf("logical-OR-expression\n");}
                      ;

conditional_expression : logical_or_expression {
                                $$ = $1;
                                printf("conditional-expression\n");
                            }
                       | logical_or_expression QUESTION expression COLON conditional_expression {printf("conditional-expression\n");}
                       ;

assignment_expression : conditional_expression {
                                $$ = $1;
                                printf("assignment-expression\n");
                            }
                      | unary_expression ASSIGN assignment_expression {printf("assignment-expression\n");}
                      ;

expression : assignment_expression {printf("expression\n");}
           ;

/* DECLARATIONS */

declaration : type_specifier init_declarator SEMICOLON {
                    // Reducing function_definition to declaration, move the new symbol table pointer NULL.
		            new_ST = NULL;
                    printf("declaration\n");
                }
            ;

init_declarator : declarator {
                        // check if the current table is global or not
                        if (currST == globalST){
                            if($1->type->type == TYPE_INT || $1->type->type == TYPE_CHAR || $1->type->type == TYPE_PTR || $1->type->type == TYPE_ARRAY){
                                // assign initial value to the symbol table entry
                                $1->initial_value = "0";
                            }
                        }
                        printf("init-declarator\n");
                    }
                | declarator ASSIGN initializer {
                        // check if a value exist in initializer
                        if($3 != NULL){
                                // assign value to the symbol table entry
                                $1->initial_value = $3->initial_value;
                                // update type of initializer
                                update_type($3, $1->type);
                            }
                        emit(OP_ASSIGN, $3->name, NULL, $1->name);
                        printf("init-declarator\n"); 
                    }
                ;

type_specifier : VOID {
                        printf("type-specifier\n");
                        push(&var_type, TYPE_VOID);
                    }
               | CHARACTER {
                        printf("type-specifier\n");
                        push(&var_type, TYPE_CHAR);
                    }
               | INTEGER {
                        printf("type-specifier\n");
                        push(&var_type, TYPE_INT);
                    }
               ;

declarator : pointer_opt direct_declarator {
                    if($1 != NULL){
                        struct symboltype* temp = create_symboltype(TYPE_PTR, 1, NULL);
                        if($2->next == NULL){
                            // it is an Array
                            temp->ptr = $2->type;
                            update_type($2, temp);
                        }
                        else{
                            // it is a function
                            temp->ptr = $2->next->_retVal;
                            $2->next->_retVal = temp;
                        }
                    }
                    $$ = $2;
                    printf("declarator\n");
                }
           ;

pointer_opt : pointer {$$ = $1;}
            | {$$ = NULL;}
            ;

direct_declarator : IDENTIFIER {
                            // new symbol table entry
                            $1 = lookup(currST, $1->name);
                            // typeentry
                            update_type($1, create_symboltype(pop(&var_type), 1, NULL));
                            $$ = $1;
                            printf("direct-declarator\n");
                        }
                  | IDENTIFIER L_BOX_BRACKET INTEGER_CONSTANT R_BOX_BRACKET {
                            $1 = lookup(currST, $1->name);
                            // type entry
                            update_type($1, create_symboltype(pop(&var_type), 1, NULL));
                            // set array flag
                            update_type($1, create_symboltype(TYPE_ARRAY, atoi($3), $1->type));
                            $$ = $1;
                            printf("direct-declarator\n");
                        }
                  | IDENTIFIER new_table L_PARENTHESIS parameter_list_opt R_PARENTHESIS {
                            // this is where the function is defined and new symbol table is created for 
                            // IDENTIFIER has parsed as a symbol table entry to the global symbol table
                            update_type($1, create_symboltype(TYPE_FUNC, 1, NULL));
                            $1->category = TYPE_FUNC;
                            // create a new symbol table for the function
                            currST->name = $1->name;
                            // link the symbol table to the global symbol table
                            $1->next = currST;
                            // store return value
                            enum symboltype_enum tempReturn = pop(&var_type);
                            if(tempReturn == TYPE_VOID){
                                currST->_retVal = create_symboltype(TYPE_VOID, 1, NULL);
                            }
                            else{
                                symboltableentry* storeReturn = lookup(currST, "retValue");
                                update_type(storeReturn, create_symboltype(tempReturn, 1, NULL));
                                currST->_retVal = storeReturn->type;
                            }
                            // keep an instan
                            // Reducing function name and parameter list to direct_declarator.
                            // This will be reduced to type_specifier declarator {block_item_list_opt}.
                            // need an instance of current symbol table for block_item_list_opt
                            new_ST = currST;
                            // printf("\n\nName %s\n\n",new_ST->name);
                            currST = globalST;
                            // printf("\n\nName %s\n\n",currST->name);
                            $$ = $1;
                            printf("direct-declarator\n");
                        }
                  ;

parameter_list_opt : parameter_list
                   | 
                   ;

pointer : ASTERISK {
                $$ = "*";
                printf("pointer\n");
            }
        ;

parameter_list : parameter_declaration {printf("parameter-list\n");}
               | parameter_list COMMA parameter_declaration {printf("parameter-list\n");}
               ;

parameter_declaration : type_specifier pointer_opt identifier_opt {
                                if($2 != NULL && $3 != NULL){
                                    $3 = lookup(currST, $3->name);
                                    struct symboltype* tempType = create_symboltype(TYPE_PTR, 1, NULL);
                                    tempType->ptr = create_symboltype(pop(&var_type), 1, NULL);
                                    update_type($3, tempType);
                                    $3->category = TYPE_PARAM;
                                    // _argList PushBack ????
                                    push_args(currST, $3);
                                }
                                else if($2 == NULL && $3 != NULL){
                                    $3 = lookup(currST, $3->name);
                                    update_type($3, create_symboltype(pop(&var_type), 1, NULL));
                                    $3->category = TYPE_PARAM;
                                    // _argList PushBack ????
                                    push_args(currST, $3);
                                }
                                else if ($2 != NULL && $3 == NULL){
                                    struct symboltype* tempType = create_symboltype(TYPE_PTR, 1, NULL);
                                    tempType->ptr = create_symboltype(pop(&var_type), 1, NULL);
                                    struct symboltableentry* tempPara = genparam(tempType, NULL);
                                    update_type(tempPara, tempType);
                                    // _argList PushBack ????
                                    push_args(currST, tempPara);
                                }
                                else{
                                    struct symboltableentry* tempPara = genparam(create_symboltype(pop(&var_type), 1, NULL), NULL);
                                    // _argList PushBack ????
                                    push_args(currST, tempPara);
                                }
                                printf("parameter-declaration\n");
                            }
                      ;

identifier_opt : IDENTIFIER {$$ = $1;}
               | {$$ = NULL;}
               ;

initializer : assignment_expression {
                    $$ = $1->loc;
                    printf("initializer\n");
                }
            ;

/* STATEMENTS */
statement : compound_statement {
                    // This is the Block. It contains a list of statements
                    $$ = $1;
                    printf("statement\n");
                }
          | expression_statement {
                    // Expressions -- Assignment, Function Call, Operations, etc.
                    $$ = create_statement();
                    $$->nextList = $1->nextList;
                    printf("statement\n");
                }
          | selection_statement {
                    // If-Else, conditional
                    $$ = $1;
                    printf("statement\n");
                }
          | iteration_statement {
                    // For Koop
                    $$ = $1;
                    printf("statement\n");
                }
          | jump_statement {
                    // This is a return statement
                    $$ = $1;
                    printf("statement\n");
                }
          ;

compound_statement : L_CURLY_BRACE block_item_list_opt R_CURLY_BRACE {
                            $$ = $2;
                            printf("compound-statement\n");
                        }
                   ;

block_item_list_opt : block_item_list {
                            $$ = $1;
                        }
                    | {
                            $$ = create_statement();
                        }
                    ;

block_item_list : block_item {
                        $$ = $1;
                        printf("block-item-list\n");
                    }
                | block_item_list N block_item {
                        $$ = $3;
                        backpatch($1->nextList, $2);
                        printf("block-item-list\n");
                    }
                ;   

block_item : declaration {
                    $$ = create_statement();
                    printf("block-item\n");
                }
           | statement {
                    $$ = $1;
                    printf("block-item\n");
                }
           ;

expression_statement : expression_opt SEMICOLON {
                            $$ = $1;
                            printf("expression-statement\n");
                        }
                     ;

expression_opt : expression {$$ = $1;}
               | {
                    $$ = create_expression();
                    $$->returnLabel = 1;
                 }
               ;

selection_statement : IF L_PARENTHESIS expression R_PARENTHESIS statement {printf("selection-statement\n");}
                    | IF L_PARENTHESIS expression R_PARENTHESIS statement ELSE statement {printf("selection-statement\n");}
                    ;

iteration_statement : FOR L_PARENTHESIS expression_opt SEMICOLON expression_opt SEMICOLON expression_opt R_PARENTHESIS statement {printf("iteration-statement\n");}
                    ;

jump_statement : RETURN expression_opt SEMICOLON {
                        if($2->returnLabel == 1){
                            // return statement without any expression
                            // function return type is void -- check
                            if(!typecheck(currST->_retVal, create_symboltype(TYPE_VOID, 1, NULL))){
                                // return type mismatch
                                yyerror("Return type mismatch with Function type\n");
                            }
                            $$ = create_statement();
                            // emit the code for return
                            emit(OP_RETURN, NULL, NULL, NULL);
                        }
                        else{
                            // return statement with expression
                            // check that the expression type is same as function return type
                            if(!typecheck(currST->_retVal, $2->loc->type)){
                                // return type mismatch
                                yyerror("Return type mismatch with Function type\n");
                            }
                            $$ = create_statement();
                            // emit the code for return
                            emit(OP_RETURN, NULL, NULL, $2->loc->name);
                        }
                        printf("jump-statement\n");
                    }
               ;

/* TRANSLATION UNIT */
translation_unit : external_declaration {printf("translation-unit\n");}
                 | translation_unit external_declaration {printf("translation-unit\n");}
                 ;

external_declaration : declaration {printf("external-declaration\n");}
                     | function_definition {printf("external-declaration\n");}
                     ;

function_definition : type_specifier declarator switch_table compound_statement {
                            // we have reduced function. Lose the instance of current symbol table
                            new_ST = NULL;
                            // emit the code for function definition

                            // just to be safe, set the current symbol table to global symbol table
                            currST = globalST;
                            printf("function-definition\n");
                        }
                    ;

/* AUX RULES */
new_table : {currST = create_symboltable("", globalST);}
          ;

N : {
        // next instruction
        $$ = nextInstr();
        printf("next-instruction\n");
    }
  ;

switch_table : {
                    currST = new_ST;
                    emit(OP_FUNC, NULL, NULL, currST->name);
               }
             ;

%%
/* C Code for functions */

void yyerror(char *s) {
    printf("Error: %s on '%s'\n", s, yytext);
}